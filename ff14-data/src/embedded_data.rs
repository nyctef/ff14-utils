use crate::model::*;
use color_eyre::eyre::{eyre, Context, Result};
use itertools::Itertools;
use rustc_hash::FxHashMap;
use std::sync::OnceLock;

// code generated by build.rs
// defines the following constants:
// - EMBEDDED_DATA_BYTES: &[u8] - rkyv-serialized EmbeddedData
// - ITEM_ID_TO_INDEX, ITEM_NAME_TO_INDEX, RECIPE_ID_TO_INDEX,
//   RECIPE_RESULT_TO_INDEX: phf lookup maps
include!(concat!(env!("OUT_DIR"), "/generated_lookups.rs"));

// types shared between build.rs and here to make sure they line up
include!(concat!(env!("CARGO_MANIFEST_DIR"), "/embedded_types.rs"));

// rkyv lets us load bytes directly into memory as rust data structures
fn get_archived_data() -> &'static ArchivedEmbeddedData {
    static ARCHIVED: OnceLock<&'static ArchivedEmbeddedData> = OnceLock::new();
    ARCHIVED.get_or_init(|| unsafe {
        // SAFETY: we don't do any validation, since we assume that the same code
        // has been used to both write and read the data, so the layout should match
        rkyv::archived_root::<EmbeddedData>(EMBEDDED_DATA_BYTES)
    })
}

fn item_row_to_item(row: &ArchivedItemRow) -> Result<Item> {
    let item_id = ItemId::new(row.id);
    let equip_slot = EquipSlotCategory::from(row.equip_slot)
        .with_context(|| format!("item {}", item_id))?;

    Ok(Item::new(
        item_id,
        row.name.to_string(),
        row.singular.to_string(),
        row.plural.to_string(),
        row.ilvl,
        row.can_be_hq,
        equip_slot,
    ))
}

fn recipe_row_to_recipe(row: &ArchivedRecipeRow, rlvl_map: &FxHashMap<RecipeLevelId, RecipeLevel>) -> Result<Recipe> {
    let recipe_id = RecipeId::new(row.id);

    let result_id = ItemId::new(row.item_result);
    let result_amount = row.amount_result;
    let result = RecipeItem::new(result_id, result_amount);

    let mut ingredients = vec![];
    for i in 0..8 {
        let ingredient_id = row.item_ingredients[i];
        let amount = row.amount_ingredients[i];
        if amount > 0 {
            ingredients.push(RecipeItem::new(ItemId::new(ingredient_id), amount));
        }
    }

    let rlvl_id = RecipeLevelId::new(row.recipe_level_table);
    let rlvl = rlvl_map
        .get(&rlvl_id)
        .ok_or_else(|| eyre!("Recipe level not found: {:?} for recipe {:?}", rlvl_id, recipe_id))?
        .clone();

    let difficulty = modify_by_factor(rlvl.base_difficulty, row.difficulty_factor);
    let durability = modify_by_factor(rlvl.base_durability, row.durability_factor);
    let quality_target = modify_by_factor(rlvl.base_quality_target, row.quality_factor);

    Ok(Recipe::new(
        recipe_id,
        ingredients,
        result,
        rlvl,
        difficulty,
        durability,
        quality_target,
        row.required_craftsmanship,
        row.required_control,
    ))
}

pub fn read_recipes() -> Result<Vec<Recipe>> {
    let archived = get_archived_data();
    let rlvls = read_rlvls()?;
    let rlvl_map: FxHashMap<RecipeLevelId, RecipeLevel> =
        rlvls.iter().map(|rl| (rl.rlvl, rl.clone())).collect();

    archived
        .recipes
        .iter()
        .map(|row| recipe_row_to_recipe(row, &rlvl_map))
        .collect()
}

/// where `factor` is an integer percentage (eg 100 = 100% = 1.0)
fn modify_by_factor(base: u16, factor: u16) -> u16 {
    ((base as u32 * factor as u32) / 100) as u16
}

pub fn read_rlvls() -> Result<Vec<RecipeLevel>> {
    let archived = get_archived_data();

    archived
        .recipe_levels
        .iter()
        .map(|row| {
            Ok(RecipeLevel::new(
                RecipeLevelId::new(row.id),
                row.progress_divider,
                row.progress_modifier,
                row.quality_divider,
                row.quality_modifier,
                row.difficulty,
                row.durability,
                row.quality,
                row.stars,
            ))
        })
        .collect()
}

pub fn read_items() -> Result<Vec<Item>> {
    get_archived_data()
        .items
        .iter()
        .map(item_row_to_item)
        .collect()
}

// These return indices into the Vec created by read_items()/read_recipes()
// which has the same ordering as the archived data
pub fn get_item_index_by_id(id: ItemId) -> Option<usize> {
    ITEM_ID_TO_INDEX.get(&id.into()).copied()
}

pub fn get_item_index_by_name(name: &str) -> Option<usize> {
    ITEM_NAME_TO_INDEX.get(name).copied()
}

pub fn get_recipe_index_by_result_item(item_id: ItemId) -> Option<usize> {
    RECIPE_RESULT_TO_INDEX.get(&item_id.into()).copied()
}

pub fn read_materia() -> Result<Vec<Materia>> {
    let archived = get_archived_data();

    archived
        .materia
        .iter()
        .map(|row| {
            let levels = (0..12)
                .map(|i| {
                    let item_id = ItemId::new(row.item_ids[i]);
                    let value = row.values[i];
                    MateriaLevel::new(item_id, (i + 1) as u8, value)
                })
                .filter(|ml| ml.item_id != ItemId::ZERO)
                .collect_vec();

            Ok(Materia::new(MateriaId::new(row.id), levels))
        })
        .collect()
}
